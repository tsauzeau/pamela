
int	main(int argc, char *argv[])
{
  struct crypt_device *cd;
  struct crypt_params_luks1 params;
  int r;

  /*
   * crypt_init() call precedes most of operations of cryptsetup API. The call is used
   * to initialize crypt device context stored in structure referenced by _cd_ in
   * the example. Second parameter is used to pass underlaying device path.
   *
   * Note:
   * If path refers to a regular file it'll be attached to a first free loop device.
   * crypt_init() operation fails in case there's no more loop device available.
   * Also, loop device will have the AUTOCLEAR flag set, so the file loopback will
   * be detached automatically.
   */

  r = crypt_init(&cd, path);
  if (r < 0 ) {
    printf("crypt_init() failed for %s.\n", path);
    return r;
  }

  printf("Context is attached to block device %s.\n", crypt_get_device_name(cd));

  /*
   * So far no data were written on your device. This will change with call of
   * crypt_format() only if you specify CRYPT_LUKS1 as device type.
   */
  printf("Device %s will be formatted to LUKS device after 5 seconds.\n"
	 "Press CTRL+C now if you want to cancel this operation.\n", path);
  sleep(5);


  /*
   * Prepare LUKS format parameters
   *
   * hash parameter defines PBKDF2 hash algorithm used in LUKS header.
   * For compatibility reason we use SHA1 here.
   */
  params.hash = "sha1";

  /*
   * data_alignment parameter is relevant only in case of the luks header
   * and the payload are both stored on same device.
   *
   * if you set data_alignment = 0, cryptsetup will autodetect
   * data_alignment according to underlaying device topology.
   */
  params.data_alignment = 0;

  /*
   * data_device parameter defines that no external device
   * for luks header will be used
   */
  params.data_device = NULL;

  /*
   * NULLs for uuid and volume_key means that these attributes will be
   * generated during crypt_format(). Volume key is generated with respect
   * to key size parameter passed to function.
   *
   * crypt_format() checks device size (LUKS header must fit there).
   */
  r = crypt_format(cd,            /* crypt context */
		   CRYPT_LUKS1,   /* LUKS1 is standard LUKS header */
		   "aes",         /* used cipher */
		   "xts-plain64", /* used block mode and IV generator*/
		   NULL,          /* generate UUID */
		   NULL,          /* generate volume key from RNG */
		   256 / 8,       /* 256bit key - here AES-128 in XTS mode, size is in bytes */
		   &params);      /* parameters above */

  if(r < 0) {
    printf("crypt_format() failed on device %s\n", crypt_get_device_name(cd));
    crypt_free(cd);
    return r;
  }
}
